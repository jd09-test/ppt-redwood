from mcp.server.fastmcp import Context, FastMCP
from loguru import logger
import sys,os,argparse

from pptx import Presentation
import json
from string import Template
from model import PresentationContent

from utils import \
    ppt_template, \
    generate_timestamped_filename, \
    process_html, \
    get_reverse_index, \
    get_layouts, \
    load_prompt_template

# Set up logging
logger.remove()
logger.add(sys.stderr, level=os.getenv('FASTMCP_LOG_LEVEL', 'WARNING'))

default_save_location = os.path.join(os.path.expanduser('~'),"Documents")

# Initialize FastMCP server
mcp = FastMCP('ppt_generator',
    instructions="""
    # PPT generator based on Redwood template MCP Server

    This server provides tools to create powerpoint presentation file based on Redwood template.

    ## Best Practices    
    - Don't use any tool unless I ask or confirm.
    - Use `get_presentation_rules` tool to get the rules for generating a presentation. 
    - Then tell me your plan, and ask me to confirm if there are other requirements. 
    - When I confirm, begin generating JSON content file. 
    - Stop here when finish generating. Ask me to confirm if there are other requirements. Don't use `generate_presentation` tool unless I ask or confirm.
    - When I confirm or ask to generate the presentation file, use `generate_presentation` tool to generate the presentation file.

    ## Tool Selection Guide
    - Use `get_presentation_rules` when: You need to get the rules for generating a presentation.
    - Use `generate_presentation` when: You already have the json content file and need to generate the presentation file.
    """,
    dependencies=[
        'pydantic',
        'pptx',
        'beautifulsoup4'
    ],)


@mcp.tool()
async def get_presentation_rules(
    ctx: Context,
    ) -> str:
    """
    Get the rules for generating a presentation.

    ## Usage
    This tool is used to get the rules for generating a presentation.
    The rules include the layout templates and the prompt template, that indicates the format of the json content you should generate.
  
    ## Best Practices
    - You must read the rule prompt before generating the presentation content. 
    - After you get the rule prompt, you should generate the json content for presentation, and write the json content to a file.

    Args:
        ctx: MCP context for logging and error handling

    Returns:
        rule_prompt: A string prompt that indicates the rules for generating a presentation.
    """
    try:
        layouts_str = get_layouts()
        prompt_str = load_prompt_template()
        prompt_template = Template(prompt_str)
        rule_prompt = prompt_template.substitute(layouts_description=layouts_str)
        logger.debug(f'prompt generated')
        return rule_prompt
    except Exception as e:
        msg = f"get prompt error: {str(e)}"
        await ctx.error(f"get prompt error: {str(e)}")
        print(msg)
        return msg


@mcp.tool()
async def generate_presentation(
    ctx: Context,
    json_content_filename: str, 
    ) -> str:
    """
    Generate the presentation file based on the json content.

    ## Usage
    This tool is used to generate the presentation file based on the json content.
    The json content is generated by `get_presentation_rules` tool.
    
    ## Best Practices
    - You must use `get_presentation_rules` tool to get the rules before generating a presentation.
    - When the json content is ready, you should use `generate_presentation` tool to generate the presentation file.

    Args:
        ctx: MCP context for logging and error handling
        json_content_file_path: json content generated by you, it's used to create presentation pages        
    """
    message = {}
    default_save_location = os.getenv(
        "WORK_DIR", 
        os.path.join(os.path.expanduser('~'),"Documents")
        )
    
    json_content_file_path = os.path.join(default_save_location,json_content_filename)
    with open(json_content_file_path, "r",encoding="utf-8") as f:
        json_content = f.read()
    
    prs_content = PresentationContent(**json.loads(json_content))    
    
    filename = generate_timestamped_filename(
        default_save_location,
        prs_content.filename,
        "pptx"
    )
    message["filename"] = os.path.basename(filename)
    message["save_location"] = default_save_location
    message["slides_count"] = 0
    theme_mode = prs_content.theme_mode    
    slides_content = prs_content.slides    

    prs = Presentation(ppt_template)
    reverse_index = get_reverse_index()

    for slide_content in slides_content:
        layout_name = slide_content.layout
        layout_index = reverse_index[layout_name]["layout_index"][theme_mode]
        placeholders_reverse = reverse_index[layout_name]["placeholders"]
        slide_layout = prs.slide_layouts[layout_index]
        slide = prs.slides.add_slide(slide_layout)

    
        for placeholder in slide_content.placeholders:            
            name = placeholder.placeholder_name
            content = placeholder.content

            if placeholder.placeholder_name.lower() == "title":
                print(f"Page {message['slides_count']+1}: {' '.join(content)}")
            try:
                index = placeholders_reverse[name][theme_mode]
                # print(name,index)
                placeholder = slide.placeholders.__getitem__(idx=index)
                text_frame = placeholder.text_frame
                text_frame.clear()
                text_frame._element.remove(text_frame.paragraphs[0]._p)
                if type(content) == list:
                    for c in content:
                        p = text_frame.add_paragraph()                
                        process_html(c,p)
                        
                # else:
                #     placeholder.text = content
            except Exception as e:
                print(f"[Error] Failed to process placeholder: {e}")
                print(f"Slide number: {message['slides_count']+1}")
                print(f"Layout name: {layout_name}")
                print(f"Placeholder name: {name}")                
                print(f"Theme mode: {theme_mode}")
                print(f"Content: {content}")
                break
        message["slides_count"] += 1

    prs.save(filename)
    return message




def main():
    """Run the MCP server with CLI argument support."""

    # Log startup information
    logger.info('Starting MCP Server')

    # Run server with appropriate transport
    logger.info('Using standard stdio transport')
    mcp.run(transport='stdio')


if __name__ == '__main__':
    main()